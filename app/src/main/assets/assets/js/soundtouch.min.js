/*

 SoundTouch JS audio processing library
 Copyright (c) Olli Parviainen
 Copyright (c) Ryan Berdeen

 This library is free software; you can redistribute it and/or
 modify it under the terms of the GNU Lesser General Public
 License as published by the Free Software Foundation; either
 version 2.1 of the License, or (at your option) any later version.
 */
(function (t) {
    function m(d, a) {
        for (var b in a)Object.defineProperty(d, b, Object.getOwnPropertyDescriptor(a, b))
    }

    function p(d, a) {
        return 1E-10 < (d > a ? d - a : a - d)
    }

    var q = [[124, 186, 248, 310, 372, 434, 496, 558, 620, 682, 744, 806, 868, 930, 992, 1054, 1116, 1178, 1240, 1302, 1364, 1426, 1488, 0], [-100, -75, -50, -25, 25, 50, 75, 100, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [-20, -15, -10, -5, 5, 10, 15, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [-4, -3, -2, -1, 1, 2, 3, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]],
        r = -10 / 1.5, u = 25 - .5 * r, h = function () {
            function d() {
                this.vector = new Float32Array(0);
                this.frameCount = this.position = 0
            }

            d.prototype = {
                get startIndex() {
                    return 2 * this.position
                }, get endIndex() {
                    return 2 * (this.position + this.frameCount)
                }, clear: function () {
                    this.receive(this.frameCount);
                    this.rewind()
                }, put: function (a) {
                    this.frameCount += a
                }, putSamples: function (a, b, c) {
                    b = 2 * (b || 0);
                    0 <= c || (c = (a.length - b) / 2);
                    var f = 2 * c;
                    this.ensureCapacity(c + this.frameCount);
                    var e = this.endIndex;
                    this.vector.set(a.subarray(b, b + f), e);
                    this.frameCount += c
                }, putBuffer: function (a, b, c) {
                    b = b || 0;
                    0 <= c || (c = a.frameCount - b);
                    this.putSamples(a.vector,
                        a.position + b, c)
                }, receive: function (a) {
                    if (!(0 <= a) || a > this.frameCount) a = this.frameCount;
                    this.frameCount -= a;
                    this.position += a
                }, receiveSamples: function (a, b) {
                    var c = this.startIndex;
                    a.set(this.vector.subarray(c, c + 2 * b));
                    this.receive(b)
                }, extract: function (a, b, c) {
                    b = this.startIndex + 2 * b;
                    a.set(this.vector.subarray(b, b + 2 * c))
                }, ensureCapacity: function (a) {
                    a *= 2;
                    this.vector.length < a ? (a = new Float32Array(a), a.set(this.vector.subarray(this.startIndex, this.endIndex)), this.vector = a, this.position = 0) : this.rewind()
                }, ensureAdditionalCapacity: function (a) {
                    this.ensureCapacity(this.frameCount +
                        a)
                }, rewind: function () {
                    0 < this.position && (this.vector.set(this.vector.subarray(this.startIndex, this.endIndex)), this.position = 0)
                }
            };
            return d
        }(), k = function () {
            function d(a) {
                a ? (this.inputBuffer = new h, this.outputBuffer = new h) : this.inputBuffer = this.outputBuffer = null
            }

            d.prototype = {
                clear: function () {
                    this.inputBuffer.clear();
                    this.outputBuffer.clear()
                }
            };
            return d
        }(), v = function () {
            function d(a) {
                k.call(this, a);
                this._reset();
                this.rate = 1
            }

            m(d.prototype, k.prototype);
            m(d.prototype, {
                set rate(a) {
                    this._rate = a
                }, _reset: function () {
                    this.prevSampleR =
                        this.prevSampleL = this.slopeCount = 0
                }, process: function () {
                    var a = this.inputBuffer.frameCount;
                    this.outputBuffer.ensureAdditionalCapacity(a / this._rate + 1);
                    a = this._transpose(a);
                    this.inputBuffer.receive();
                    this.outputBuffer.put(a)
                }, _transpose: function (a) {
                    if (0 === a)return 0;
                    for (var b = this.inputBuffer.vector, c = this.inputBuffer.startIndex, f = this.outputBuffer.vector,
                             e = this.outputBuffer.endIndex, d = 0,
                             g = 0; 1 > this.slopeCount;)f[e + 2 * g] = (1 - this.slopeCount) * this.prevSampleL + this.slopeCount * b[c], f[e + 2 * g + 1] = (1 - this.slopeCount) *
                        this.prevSampleR + this.slopeCount * b[c + 1], g++, this.slopeCount += this._rate;
                    --this.slopeCount;
                    if (1 != a)a:for (; ;) {
                        for (; 1 < this.slopeCount;)if (--this.slopeCount, d++, d >= a - 1)break a;
                        var n = c + 2 * d;
                        f[e + 2 * g] = (1 - this.slopeCount) * b[n] + this.slopeCount * b[n + 2];
                        f[e + 2 * g + 1] = (1 - this.slopeCount) * b[n + 1] + this.slopeCount * b[n + 3];
                        g++;
                        this.slopeCount += this._rate
                    }
                    this.prevSampleL = b[c + 2 * a - 2];
                    this.prevSampleR = b[c + 2 * a - 1];
                    return g
                }
            });
            return d
        }(), w = function () {
            function d(a, b) {
                k.call(this, b);
                this.bQuickSeek = !0;
                this.bMidBufferDirty = !1;
                this.pMidBuffer = null;
                this.overlapLength = 0;
                this.bAutoSeekSetting = this.bAutoSeqSetting = !0;
                this._tempo = 1;
                this.setParameters(a, 0, 0, 8)
            }

            m(d.prototype, k.prototype);
            m(d.prototype, {
                clear: function () {
                    k.prototype.clear.call(this);
                    this._clearMidBuffer()
                }, _clearMidBuffer: function () {
                    this.bMidBufferDirty && (this.bMidBufferDirty = !1, this.pMidBuffer = null)
                }, setParameters: function (a, b, c, f) {
                    0 < a && (this.sampleRate = a);
                    0 < f && (this.overlapMs = f);
                    0 < b ? (this.sequenceMs = b, this.bAutoSeqSetting = !1) : this.bAutoSeqSetting = !0;
                    0 < c ? (this.seekWindowMs =
                        c, this.bAutoSeekSetting = !1) : this.bAutoSeekSetting = !0;
                    this.calcSeqParameters();
                    this.calculateOverlapLength(this.overlapMs);
                    this.tempo = this._tempo
                }, set tempo(a) {
                    this._tempo = a;
                    this.calcSeqParameters();
                    this.nominalSkip = this._tempo * (this.seekWindowLength - this.overlapLength);
                    this.skipFract = 0;
                    this.sampleReq = Math.max(Math.floor(this.nominalSkip + .5) + this.overlapLength, this.seekWindowLength) + this.seekLength
                }, get tempo() {
                    return this._tempo
                }, get inputChunkSize() {
                    return this.sampleReq
                }, get outputChunkSize() {
                    return this.overlapLength +
                        Math.max(0, this.seekWindowLength - 2 * this.overlapLength)
                }, calculateOverlapLength: function (a) {
                    a = this.sampleRate * a / 1E3;
                    16 > a && (a = 16);
                    this.overlapLength = a - a % 8;
                    this.pRefMidBuffer = new Float32Array(2 * this.overlapLength);
                    this.pMidBuffer = new Float32Array(2 * this.overlapLength)
                }, checkLimits: function (a, b, c) {
                    return a < b ? b : a > c ? c : a
                }, calcSeqParameters: function () {
                    var a;
                    this.bAutoSeqSetting && (a = 150 + -50 * this._tempo, a = this.checkLimits(a, 50, 125), this.sequenceMs = Math.floor(a + .5));
                    this.bAutoSeekSetting && (a = u + r * this._tempo,
                        a = this.checkLimits(a, 15, 25), this.seekWindowMs = Math.floor(a + .5));
                    this.seekWindowLength = Math.floor(this.sampleRate * this.sequenceMs / 1E3);
                    this.seekLength = Math.floor(this.sampleRate * this.seekWindowMs / 1E3)
                }, set quickSeek(a) {
                    this.bQuickSeek = a
                }, seekBestOverlapPosition: function () {
                    return this.bQuickSeek ? this.seekBestOverlapPositionStereoQuick() : this.seekBestOverlapPositionStereo()
                }, seekBestOverlapPositionStereo: function () {
                    var a, b, c, f;
                    this.precalcCorrReferenceStereo();
                    b = Number.MIN_VALUE;
                    for (f = a = 0; f < this.seekLength; f++)c =
                        this.calcCrossCorrStereo(2 * f, this.pRefMidBuffer), c > b && (b = c, a = f);
                    return a
                }, seekBestOverlapPositionStereoQuick: function () {
                    var a, b, c, f, e, d, g;
                    this.precalcCorrReferenceStereo();
                    c = Number.MIN_VALUE;
                    for (e = d = b = 0; 4 > e; e++) {
                        for (a = 0; q[e][a];) {
                            g = d + q[e][a];
                            if (g >= this.seekLength)break;
                            f = this.calcCrossCorrStereo(2 * g, this.pRefMidBuffer);
                            f > c && (c = f, b = g);
                            a++
                        }
                        d = b
                    }
                    return b
                }, precalcCorrReferenceStereo: function () {
                    var a, b, c;
                    for (a = 0; a < this.overlapLength; a++)c = a * (this.overlapLength - a), b = 2 * a, this.pRefMidBuffer[b] = this.pMidBuffer[b] *
                        c, this.pRefMidBuffer[b + 1] = this.pMidBuffer[b + 1] * c
                }, calcCrossCorrStereo: function (a, b) {
                    var c = this.inputBuffer.vector;
                    a += this.inputBuffer.startIndex;
                    var d, e, l;
                    d = 0;
                    for (e = 2; e < 2 * this.overlapLength; e += 2)l = e + a, d += c[l] * b[e] + c[l + 1] * b[e + 1];
                    return d
                }, overlap: function (a) {
                    this.overlapStereo(2 * a)
                }, overlapStereo: function (a) {
                    var b = this.inputBuffer.vector;
                    a += this.inputBuffer.startIndex;
                    var c = this.outputBuffer.vector, d = this.outputBuffer.endIndex, e, l, g, n, h, k, m;
                    n = 1 / this.overlapLength;
                    for (e = 0; e < this.overlapLength; e++)g =
                        (this.overlapLength - e) * n, h = e * n, l = 2 * e, k = l + a, m = l + d, c[m + 0] = b[k + 0] * h + this.pMidBuffer[l + 0] * g, c[m + 1] = b[k + 1] * h + this.pMidBuffer[l + 1] * g
                }, process: function () {
                    var a, b;
                    if (null === this.pMidBuffer) {
                        if (this.inputBuffer.frameCount < this.overlapLength)return;
                        this.pMidBuffer = new Float32Array(2 * this.overlapLength);
                        this.inputBuffer.receiveSamples(this.pMidBuffer, this.overlapLength)
                    }
                    for (; this.inputBuffer.frameCount >= this.sampleReq;)a = this.seekBestOverlapPosition(), this.outputBuffer.ensureAdditionalCapacity(this.overlapLength),
                        this.overlap(Math.floor(a)), this.outputBuffer.put(this.overlapLength), b = this.seekWindowLength - 2 * this.overlapLength, 0 < b && this.outputBuffer.putBuffer(this.inputBuffer, a + this.overlapLength, b), a = this.inputBuffer.startIndex + 2 * (a + this.seekWindowLength - this.overlapLength), this.pMidBuffer.set(this.inputBuffer.vector.subarray(a, a + 2 * this.overlapLength)), this.skipFract += this.nominalSkip, a = Math.floor(this.skipFract), this.skipFract -= a, this.inputBuffer.receive(a)
                }
            });
            return d
        }(), x = function () {
            function d(a) {
                this.rateTransposer =
                    new v(!1);
                this.tdStretch = new w(a, !1);
                this.inputBuffer = new h;
                this._intermediateBuffer = new h;
                this.outputBuffer = new h;
                this._tempo = this._rate = 0;
                this.virtualTempo = this.virtualRate = this.virtualPitch = 1;
                this._calculateEffectiveRateAndTempo()
            }

            d.prototype = {
                clear: function () {
                    this.rateTransposer.clear();
                    this.tdStretch.clear()
                }, get rate() {
                    return this._rate
                }, set rate(a) {
                    this.virtualRate = a;
                    this._calculateEffectiveRateAndTempo()
                }, set rateChange(a) {
                    this.rate = 1 + .01 * a
                }, get tempo() {
                    return this._tempo
                }, set tempo(a) {
                    this.virtualTempo =
                        a;
                    this._calculateEffectiveRateAndTempo()
                }, set tempoChange(a) {
                    this.tempo = 1 + .01 * a
                }, set pitch(a) {
                    this.virtualPitch = a;
                    this._calculateEffectiveRateAndTempo()
                }, set pitchOctaves(a) {
                    this.pitch = Math.exp(.69314718056 * a);
                    this._calculateEffectiveRateAndTempo()
                }, set pitchSemitones(a) {
                    this.pitchOctaves = a / 12
                }, _calculateEffectiveRateAndTempo: function () {
                    var a = this._tempo, b = this._rate;
                    this._tempo = this.virtualTempo / this.virtualPitch;
                    this._rate = this.virtualRate * this.virtualPitch;
                    p(this._tempo, a) && (this.tdStretch.tempo =
                        this._tempo);
                    p(this._rate, b) && (this.rateTransposer.rate = this._rate);
                    1 < this._rate ? this.outputBuffer != this.rateTransposer.outputBuffer && (this.tdStretch.inputBuffer = this.inputBuffer, this.tdStretch.outputBuffer = this._intermediateBuffer, this.rateTransposer.inputBuffer = this._intermediateBuffer, this.rateTransposer.outputBuffer = this.outputBuffer) : this.outputBuffer != this.tdStretch.outputBuffer && (this.rateTransposer.inputBuffer = this.inputBuffer, this.rateTransposer.outputBuffer = this._intermediateBuffer, this.tdStretch.inputBuffer =
                            this._intermediateBuffer, this.tdStretch.outputBuffer = this.outputBuffer)
                }, process: function () {
                    1 < this._rate ? (this.tdStretch.process(), this.rateTransposer.process()) : (this.rateTransposer.process(), this.tdStretch.process())
                }
            };
            return d
        }(), y = function () {
            function d(a, b, c) {
                this.pipe = c;
                this.sourceSound = a;
                this.channels = b;
                this.historyBufferSize = 22050;
                this._position = this.outputBufferPosition = this._sourcePosition = 0
            }

            d.prototype = {
                get position() {
                    return this._position
                }, set position(a) {
                    if (a > this._position)throw new RangeError("New position may not be greater than current position");
                    var b = this.outputBufferPosition - (this._position - a);
                    if (0 > b)throw new RangeError("New position falls outside of history buffer");
                    this.outputBufferPosition = b;
                    this._position = a
                }, get sourcePosition() {
                    return this._sourcePosition
                }, set sourcePosition(a) {
                    this.clear();
                    this._sourcePosition = a
                }, get inputBuffer() {
                    return this.pipe.inputBuffer
                }, get outputBuffer() {
                    return this.pipe.outputBuffer
                }, fillInputBuffer: function (a) {
                    for (var b = new Float32Array(2 * a), c = this.sourceSound.getChannelData(0),
                             d = 1 == this.channels ? c : this.sourceSound.getChannelData(1),
                             e = 0; e < a; e++)b[2 * e] = c[e + this._sourcePosition], b[2 * e + 1] = d[e + this._sourcePosition];
                    a = Math.min(a, c.length - this._sourcePosition);
                    this._sourcePosition += a;
                    this.inputBuffer.putSamples(b, 0, a)
                }, fillOutputBuffer: function (a) {
                    for (; this.outputBuffer.frameCount < a;) {
                        this.fillInputBuffer(16384 - this.inputBuffer.frameCount);
                        if (16384 > this.inputBuffer.frameCount)break;
                        this.pipe.process()
                    }
                }, extract: function (a, b) {
                    this.fillOutputBuffer(this.outputBufferPosition + b);
                    var c = Math.min(b, this.outputBuffer.frameCount - this.outputBufferPosition);
                    this.outputBuffer.extract(a, this.outputBufferPosition, c);
                    var d = this.outputBufferPosition + c;
                    this.outputBufferPosition = Math.min(this.historyBufferSize, d);
                    this.outputBuffer.receive(Math.max(d - this.historyBufferSize, 0));
                    this._position += c;
                    return c
                }, clear: function () {
                    this.pipe.clear();
                    this.outputBufferPosition = 0
                }
            };
            return d
        }();
    t.soundtouch = {SimpleFilter: y, SoundTouch: x}
})(window);
